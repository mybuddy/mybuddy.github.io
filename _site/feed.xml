<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding4Fun</title>
    <description></description>
    <link>http://www.felixyan.com/</link>
    <atom:link href="http://www.felixyan.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 18 Mar 2017 17:52:22 +0800</pubDate>
    <lastBuildDate>Sat, 18 Mar 2017 17:52:22 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>进程、线程基础</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;1. 基本概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#java&quot; id=&quot;markdown-toc-java&quot;&gt;2. Java中的进程、线程&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#java-1&quot; id=&quot;markdown-toc-java-1&quot;&gt;Java中创建线程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#java-2&quot; id=&quot;markdown-toc-java-2&quot;&gt;Java中创建进程&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#thread&quot; id=&quot;markdown-toc-thread&quot;&gt;3. Thread类的使用&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;线程的状态&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;上下文切换&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#thread-1&quot; id=&quot;markdown-toc-thread-1&quot;&gt;Thread类中的方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进程、线程的基本概念，及Java中进程、线程的使用。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 基本概念&lt;/h2&gt;

&lt;p&gt;进程：每个进程对应一个程序，&lt;strong&gt;对应一定的内存地址空间&lt;/strong&gt;，且只能使用其自己的内存空间，进程间互不干扰。进程保存了程序每个时刻的运行状态，进程暂停时会保存其当前的状态（进程标识、进程使用的资源等），下次切换回来时，根据之前保存的状态进行恢复，然后继续执行。&lt;/p&gt;

&lt;p&gt;线程：一个进程包含多个线程，但这些&lt;strong&gt;线程共享进程占用的资源和地址空间&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;是操作系统进行&lt;strong&gt;资源分配&lt;/strong&gt;的基本单位，而&lt;strong&gt;线程&lt;/strong&gt;是操作系统进行&lt;strong&gt;调度&lt;/strong&gt;的基本单位。&lt;/p&gt;

&lt;p&gt;进程使得操作系统的并发性成为可能，而线程使得进程内部的并发成为可能。&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;2. Java中的进程、线程&lt;/h2&gt;

&lt;p&gt;Java中，&lt;strong&gt;一个应用程序对应一个JVM实例&lt;/strong&gt;（亦称JVM进程），名字一般默认为java.exe或javaw.exe。&lt;/p&gt;

&lt;p&gt;Java采用&lt;strong&gt;单线程编程模型&lt;/strong&gt;，即程序中没有主动创建线程的话，默认只会创建一个线程，称为主线程，但不代表JVM中只有一个线程，JVM实例在创建的时候，会同时创建很多其他线程（如垃圾收集器线程）。&lt;/p&gt;

&lt;h3 id=&quot;java-1&quot;&gt;Java中创建线程&lt;/h3&gt;

&lt;p&gt;2种方式，1. 继承Thread类；2. 实现Runnable接口。&lt;/p&gt;

&lt;h3 id=&quot;java-2&quot;&gt;Java中创建进程&lt;/h3&gt;

&lt;p&gt;2种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过ProcessBuilder.start方法创建；
ProcessBuilder.start方法中调用了ProcessImpl.start方法，ProcessImpl类本身继承了Process类，而在ProcessImpl.start方法中new了一个ProcessImpl实例并返回。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过Runtime.exec方法创建。
Runtime.exec方法中调用了ProcessBuilder.start方法。&lt;strong&gt;Runtime，即运行时，表示当前进程所在的虚拟机实例。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过ProcessBuilder.start方法&lt;/p&gt;

    &lt;p&gt;```java
 ProcessBuilder pb = new ProcessBuilder(“cmd”,”/c”,”ipconfig/all”);
 Process process = pb.start();
 Scanner scanner = new Scanner(process.getInputStream());&lt;/p&gt;

    &lt;p&gt;while(scanner.hasNextLine()){
   System.out.println(scanner.nextLine());
 }
 scanner.close();
 ```&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过Runtime.exec方法&lt;/p&gt;

    &lt;p&gt;```java
 String cmd = “cmd “+”/c “+”ipconfig/all”;
 Process process = Runtime.getRuntime().exec(cmd); // 单例方式获取Runtime实例
 Scanner scanner = new Scanner(process.getInputStream());&lt;/p&gt;

    &lt;p&gt;while(scanner.hasNextLine()){
   System.out.println(scanner.nextLine());
 }
 scanner.close();
 ```&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;thread&quot;&gt;3. Thread类的使用&lt;/h2&gt;

&lt;p&gt;线程的状态及对应的方法
&lt;img src=&quot;http://images.cnitblog.com/blog/288799/201409/061046391107893.jpg&quot; alt=&quot;线程的状态及对应的方法&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;线程的状态&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;线程包括5个状态：创建（new）、就绪（runnable）、运行（running）、阻塞（blocked）[time waiting、waiting]、消亡（dead）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;线程的创建状态，new一个线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线程创建后，不会立即进入就绪状态&lt;/strong&gt;，因为线程运行需要一些条件（如内存资源，线程私有的程序计数器、Java栈、本地方法栈），只有条件满足了才进入就绪状态。调用start方法会为线程分配需要的资源。&lt;/p&gt;

&lt;p&gt;线程进入就绪状态后，不代表立即能获取CPU执行时间，当得到CPU执行时间后，才进入运行状态。&lt;/p&gt;

&lt;p&gt;线程运行过程中，可能有多个原因导致线程无法继续运行，如sleep()、join()/wait()、同步块阻塞。对应time waiting、waiting、blocked状态。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;上下文切换&lt;/h3&gt;

&lt;p&gt;线程的上下文切换实际上就是&lt;strong&gt;存储和恢复CPU状态的过程&lt;/strong&gt;，它使得线程能够从中断点恢复执行。&lt;/p&gt;

&lt;h3 id=&quot;thread-1&quot;&gt;Thread类中的方法&lt;/h3&gt;

&lt;p&gt;线程优先级：最大10，最小1，默认5。&lt;/p&gt;

&lt;p&gt;线程运行相关方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;start。&lt;br /&gt;
启动一个线程，为线程分配需要的资源。&lt;/li&gt;
  &lt;li&gt;run。&lt;/li&gt;
  &lt;li&gt;sleep。&lt;br /&gt;
交出CPU，进入&lt;strong&gt;阻塞状态，不释放锁&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;yield。&lt;br /&gt;
交出CPU，重回&lt;strong&gt;就绪状态，不释放锁&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;join。&lt;br /&gt;
等待thread执行完毕或等待指定时间，内部使用wait实现。交出CPU，进入&lt;strong&gt;阻塞状态，释放锁&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;interrupt。&lt;br /&gt;
&lt;strong&gt;中断处于阻塞状态的线程&lt;/strong&gt;（使其抛出中断异常）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程属性相关方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;getId。&lt;/li&gt;
  &lt;li&gt;getName、setName。&lt;/li&gt;
  &lt;li&gt;getPriority、setPriority。&lt;/li&gt;
  &lt;li&gt;setDaemon、isDaemon。
&lt;strong&gt;守护线程依赖于创建它的线程，而用户线程不依赖。&lt;/strong&gt;创建守护线程的线程运行完毕后，守护线程也会随之消亡，而用户线程会一直运行到其结束。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;获取当前线程的静态方法Thread.currentThread()。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3910667.html&quot;&gt;Java多线程基础：进程和线程之由来&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3913517.html&quot;&gt;Java并发编程：如何创建线程？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3920357.html&quot;&gt;Java并发编程：Thread类的使用&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Aug 2016 20:32:01 +0800</pubDate>
        <link>http://www.felixyan.com/2016/08/01/process-thread-foundation/</link>
        <guid isPermaLink="true">http://www.felixyan.com/2016/08/01/process-thread-foundation/</guid>
        
        <category>并发编程</category>
        
        <category>java</category>
        
        
        <category>并发编程</category>
        
      </item>
    
      <item>
        <title>git 笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#git&quot; id=&quot;markdown-toc-git&quot;&gt;1. git基本命令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;1.1 基本命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#diff&quot; id=&quot;markdown-toc-diff&quot;&gt;1.2 diff命令&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;2. 本地库与远程库关联的2种方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;3. 分支&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;3.1 分支基本命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;3.2 冲突&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;3.3 保护工作区&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;4. 多人协作的工作模式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;4.1 多人在同一公共分支开发&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;4.2 多人在各自私有分支开发&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;5. 远程库&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tag&quot; id=&quot;markdown-toc-tag&quot;&gt;6. 标签tag&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;7. 撤销命令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#commit-levelresetcheckoutrevert&quot; id=&quot;markdown-toc-commit-levelresetcheckoutrevert&quot;&gt;7.1 commit level（reset、checkout、revert）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#file-levelresetcheckout&quot; id=&quot;markdown-toc-file-levelresetcheckout&quot;&gt;7.2 file level（reset、checkout）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;8. 撤销的正确姿势&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;9. 其他&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;10. 参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;公司从去年底开始使用git作为版本控制工具，这是当时做的笔记。&lt;/p&gt;

&lt;h2 id=&quot;git&quot;&gt;1. git基本命令&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;1.1 基本命令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git init&lt;/code&gt;&lt;br /&gt;
创建本地git仓库&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;&lt;br /&gt;
查看git状态&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git add 文件1 [文件2...文件n]&lt;/code&gt;&lt;br /&gt;
添加一个/多个文件到暂存区。&lt;code class=&quot;highlighter-rouge&quot;&gt;git add .&lt;/code&gt;添加所有改动的文件到暂存区&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm 文件1 [文件2...文件n]&lt;/code&gt;&lt;br /&gt;
删除一个或多个文件，也可先在资源管理器或命令行中删除，git会发现有文件被删除&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &#39;提交说明&#39;&lt;/code&gt;&lt;br /&gt;
将暂存区的代码提交到版本库&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt;&lt;br /&gt;
查看commit记录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git log --pretty=oneline --abbrev-commit&lt;/code&gt;&lt;br /&gt;
查看commit记录（单行，commit_id缩略）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git reflog&lt;/code&gt;&lt;br /&gt;
查看命令记录&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;diff&quot;&gt;1.2 diff命令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt;&lt;br /&gt;
查看工作区和暂存区之间的差异（a.暂存区，b.工作区）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff --cached&lt;/code&gt;&lt;br /&gt;
查看暂存区和上次commit之间的差异（a.上次commit，b.暂存区)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff HEAD&lt;/code&gt;&lt;br /&gt;
查看工作区和上次commit之间的差异（a.上次commit，b.工作区）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上3个命令后都可接具体的文件/目录，以查看指定文件/目录的差异，如&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff 文件&lt;/code&gt;。
另，以上3个命令后都可接–stat以查看全局改动，如&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff --stat&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2. 本地库与远程库关联的2种方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;本地已有仓库
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git remote add origin git@server-name:path/repo-name.git&lt;/code&gt;&lt;br /&gt;
 把一个已有的本地仓库关联到远程库（origin是远程库的默认叫法，可以改成别的）&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push -u origin master&lt;/code&gt;&lt;br /&gt;
 第一次推送master分支的所有内容（-u参数，git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来）&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin master&lt;/code&gt;&lt;br /&gt;
 本地提交后，推送最新修改到远程库&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;本地没有仓库&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone git@github.com:mybuddy/gitskills.git&lt;/code&gt;&lt;br /&gt;
 从远程库克隆&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3. 分支&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.1 分支基本命令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt;&lt;br /&gt;
查看分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch &amp;lt;name&amp;gt;&lt;/code&gt;&lt;br /&gt;
创建分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout &amp;lt;name&amp;gt;&lt;/code&gt;&lt;br /&gt;
切换分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b &amp;lt;name&amp;gt;&lt;/code&gt;&lt;br /&gt;
创建+切换分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge &amp;lt;name&amp;gt;&lt;/code&gt;&lt;br /&gt;
合并某分支到当前分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch -d &amp;lt;name&amp;gt;&lt;/code&gt;&lt;br /&gt;
删除分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch -D &amp;lt;name&amp;gt;&lt;/code&gt;&lt;br /&gt;
删除一个没有被合并过的分支（强行删除）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git log --graph&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git log --graph --pretty=oneline --abbrev-commit&lt;/code&gt;&lt;br /&gt;
分支合并图&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge —no-ff -m &#39;说明&#39; &amp;lt;name&amp;gt;&lt;/code&gt;&lt;br /&gt;
不使用fast forward模式合并，合并会产生commit。fast forward模式合并不会产生commit。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;3.2 冲突&lt;/h3&gt;

&lt;p&gt;当git自动合并分支遇到冲突时，必须先解决冲突，然后再提交，最后合并完成。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge &amp;lt;name&amp;gt;&lt;/code&gt; 尝试合并，遇到冲突，手动解决冲突&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git add 文件&lt;/code&gt; 冲突解决后，add到暂存区&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 提交&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;3.3 保护工作区&lt;/h3&gt;

&lt;p&gt;当需临时开分支（如修复一个紧急的bug），而手头工作没有完成时，可以先保护工作现场，再开分支，待bug修复后，恢复工作现场。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash&lt;/code&gt;&lt;br /&gt;
保护工作现场&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash list&lt;/code&gt;&lt;br /&gt;
查看工作现场&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash apply&lt;/code&gt;&lt;br /&gt;
恢复工作现场，stash内容并不删除&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash drop&lt;/code&gt;&lt;br /&gt;
删除工作现场&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash pop&lt;/code&gt;&lt;br /&gt;
恢复工作现场的同时，stash内容也一并删除&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash apply stash@{0}&lt;/code&gt;&lt;br /&gt;
可以多次stash，恢复的时候，先用&lt;code class=&quot;highlighter-rouge&quot;&gt;git stash list&lt;/code&gt;查看，然后恢复指定的stash&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;4. 多人协作的工作模式&lt;/h2&gt;

&lt;h3 id=&quot;section-7&quot;&gt;4.1 多人在同一公共分支开发&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;从master拉一个公共分支，多人均在该公共分支开发；&lt;/li&gt;
  &lt;li&gt;试图用&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin &amp;lt;branch-name&amp;gt;&lt;/code&gt;推送自己的修改；&lt;/li&gt;
  &lt;li&gt;如果推送失败，则因为远程分支比你的本地更新，需要先用&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;试图合并；&lt;/li&gt;
  &lt;li&gt;如果合并有冲突，则解决冲突，并在本地提交；&lt;/li&gt;
  &lt;li&gt;没有冲突或者解决掉冲突后，再用&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin &amp;lt;branch-name&amp;gt;&lt;/code&gt;推送就能成功；&lt;br /&gt;
如果&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;提示&lt;em&gt;“no tracking information”&lt;/em&gt;，则说明本地分支和远程分支的链接关系没有创建，使用以下命令关联
&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch --track origin/branch-name &amp;lt;branch-name&amp;gt;&lt;/code&gt; 或 
&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch --set-upstream-to=origin/branch-name &amp;lt;branch-name&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种方式，若使用gitlab来合并代码、review代码，仅能在公共分支merge到master分支时，在gitlab上提merge request来完成。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;4.2 多人在各自私有分支开发&lt;/h3&gt;

&lt;p&gt;多人在各自私有分支开发，时不时地merge到公共分支，并pull公共分支，merge到自己的分支，最后开发完毕再merge到公共分支。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。&lt;/p&gt;

  &lt;p&gt;&lt;img src=&quot;http://oatuajceb.bkt.clouddn.com/image/git%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于我们使用gitlab来合并代码、review代码的情况，则具体如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从远程库dev分支创建各自的分支dev1、dev2，各自本地除了自己的分支外，还有原分支dev；&lt;/li&gt;
  &lt;li&gt;RD1的本地dev1分支push到远程库dev1后，提merge request到dev分支，结对人review代码并accept merge request；&lt;/li&gt;
  &lt;li&gt;RD2使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; 更新本地dev分支，然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge dev2&lt;/code&gt;在本地将dev分支 merge到dev2分支，并push到远程库dev2后，最后merge request到dev分支；&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;这个过程发生了2次merge，一个是私有分支merge到公共分支，通过在gitlab上提merge request完成；另一个是公共分支merge到私有分支，通过在本地使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt;命令完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-9&quot;&gt;5. 远程库&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git remote -v&lt;/code&gt;&lt;br /&gt;
查看远程库信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b branch-name origin/branch-name&lt;/code&gt;&lt;br /&gt;
在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch --track origin/branch-name &amp;lt;branch-name&amp;gt;&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch --set-upstream-to=origin/branch-name &amp;lt;branch-name&amp;gt;&lt;/code&gt;&lt;br /&gt;
建立本地分支和远程分支的关联&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tag&quot;&gt;6. 标签tag&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag &amp;lt;name&amp;gt; [commit id]&lt;/code&gt;&lt;br /&gt;
新建一个标签，默认为HEAD，也可以指定一个commit id&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag -a &amp;lt;tagname&amp;gt; -m &#39;说明&#39;&lt;/code&gt;&lt;br /&gt;
可以指定标签信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag -s &amp;lt;tagname&amp;gt; -m &#39;说明&#39;&lt;/code&gt;&lt;br /&gt;
可以用PGP签名标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag&lt;/code&gt;&lt;br /&gt;
查看所有标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git show &amp;lt;tagname&amp;gt;&lt;/code&gt;&lt;br /&gt;
查看标签信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin &amp;lt;tagname&amp;gt;&lt;/code&gt;&lt;br /&gt;
推送一个本地标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin --tags&lt;/code&gt;&lt;br /&gt;
推送全部未推送过的本地标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag -d &amp;lt;tagname&amp;gt;&lt;/code&gt;&lt;br /&gt;
删除一个本地标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin :refs/tags/&amp;lt;tagname&amp;gt;&lt;/code&gt;&lt;br /&gt;
删除一个远程标签&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;7. 撤销命令&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;reset/checkout/revert 区别&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;commit-levelresetcheckoutrevert&quot;&gt;7.1 commit level（reset、checkout、revert）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;git reset&lt;/strong&gt;&lt;br /&gt;
用于撤销自己的分支所做的修改。（会修改commit history）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git reset --soft HEAD&lt;/code&gt;&lt;br /&gt;
 仅修改commit history&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git reset [--mixed] HEAD&lt;/code&gt;&lt;br /&gt;
 仅丢弃暂存区的修改，工作区不受影响（HEAD表示最新的版本）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git reset --hard HEAD&lt;/code&gt;&lt;br /&gt;
 丢弃暂存区、工作区的修改 HEAD^，HEAD^^，HEAD~5，commit_id（前几位即可，如7位）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;git checkout&lt;/strong&gt;&lt;br /&gt;
可能会修改工作区，所以checkout的时候git会提醒&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout branch_name&lt;/code&gt;&lt;br /&gt;
 （将HEAD移动到其他分支）用于切换分支&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout commit_id&lt;/code&gt;&lt;br /&gt;
 （将HEAD移动到指定的commit，类似于上面）用于快速查看历史版本，但不可直接修改，修改必须拉相应分支&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;git revert&lt;/strong&gt; &lt;br /&gt;
用于撤销公共的分支所做的修改。（不会修改commit history，而是新增一个commit）可能会修改工作区，所以revert的时候git会提醒&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git revert HEAD~2&lt;/code&gt;&lt;br /&gt;
 （仅撤销HEAD~2所做的修改，并创建一个新的commit）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;file-levelresetcheckout&quot;&gt;7.2 file level（reset、checkout）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;git reset&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git reset HEAD [--] 文件&lt;/code&gt;&lt;br /&gt;
 –soft、–mixed、–hard参数无效，结果均为仅丢弃暂存区的修改，工作区不受影响&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;git checkout&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout HEAD~2 [--] 文件&lt;/code&gt;&lt;br /&gt;
 （HEAD不移动）暂存区不修改，工作区修改，用于快速查看该文件的历史版本（效果类似于commit level的&lt;code class=&quot;highlighter-rouge&quot;&gt;git reset —hard HEAD~2&lt;/code&gt;，但局限于该文件）&lt;br /&gt;
如果checkout一个文件的某版本后，add并commit该文件，则效果类似revert该文件到某版本，不同的是该版本之后的所有修改均被撤销，而revert只会撤销指定版本的修改&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：git命令中的文件、目录前可以加&lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;以便与参数隔开。如&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout HEAD~2 -- 文件&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-11&quot;&gt;8. 撤销的正确姿势&lt;/h2&gt;

&lt;p&gt;做了无数次试验后，总结的revert的姿势：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git revert commit_id&lt;/code&gt;，然后push，merge request&lt;br /&gt;
优点：可以全局revert&lt;br /&gt;
缺点：只能revert该commit的修改，如果要revert多次commit，则要多次revert最后再push，merge request&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout commit_id 文件1 文件2 [...文件n]&lt;/code&gt;，然后add，commit，push，merge request&lt;br /&gt;
优点：可以revert多次commit&lt;br /&gt;
缺点：必须把要revert的文件一一列出来，不能全局revert&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-12&quot;&gt;9. 其他&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone -b &amp;lt;branch&amp;gt; &amp;lt;remote_repo&amp;gt;&lt;/code&gt;&lt;br /&gt;
git clone默认会把仓库中的所有分支都复制到本地，该命令可仅克隆指定的分支&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-13&quot;&gt;10. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;廖雪峰git教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting/&quot;&gt;Reset, Checkout, and Revert&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 20 Jul 2016 01:54:54 +0800</pubDate>
        <link>http://www.felixyan.com/2016/07/20/git-note/</link>
        <guid isPermaLink="true">http://www.felixyan.com/2016/07/20/git-note/</guid>
        
        <category>git</category>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>第一篇文章</title>
        <description>
&lt;p&gt;第一篇文章。博客使用jekyll搭建在github上。&lt;/p&gt;

&lt;p&gt;不好意思，第一篇文章没有内容。&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Jul 2016 22:14:54 +0800</pubDate>
        <link>http://www.felixyan.com/2016/07/19/first-post/</link>
        <guid isPermaLink="true">http://www.felixyan.com/2016/07/19/first-post/</guid>
        
        
      </item>
    
  </channel>
</rss>
