---
layout: post
title:  "git 笔记"
date:   2016-07-20 01:54:54 +0800
categories: git
tags: git
---

* content
{:toc}

公司从去年底开始使用git作为版本控制工具，这是当时做的笔记。





## 1. git基本命令

### 1.1 基本命令

+ `git init`  
创建本地git仓库
+ `git status`  
查看git状态
+ `git add 文件1 [文件2...文件n]`  
添加一个/多个文件到暂存区。`git add .`添加所有改动的文件到暂存区
+ `git rm 文件1 [文件2...文件n]`  
删除一个或多个文件，也可先在资源管理器或命令行中删除，git会发现有文件被删除
+ `git commit -m '提交说明'`  
将暂存区的代码提交到版本库
+ `git log`  
查看commit记录
+ `git log --pretty=oneline --abbrev-commit`  
查看commit记录（单行，commit_id缩略）
+ `git reflog`  
查看命令记录

### 1.2 diff命令

+ `git diff`  
查看工作区和暂存区之间的差异（a.暂存区，b.工作区）
+ `git diff --cached`  
查看暂存区和上次commit之间的差异（a.上次commit，b.暂存区)
+ `git diff HEAD`  
查看工作区和上次commit之间的差异（a.上次commit，b.工作区）  

以上3个命令后都可接具体的文件/目录，以查看指定文件/目录的差异，如`git diff 文件`。
另，以上3个命令后都可接--stat以查看全局改动，如`git diff --stat`。

## 2. 本地库与远程库关联的2种方法

+ 本地已有仓库  
 1. `git remote add origin git@server-name:path/repo-name.git`  
 把一个已有的本地仓库关联到远程库（origin是远程库的默认叫法，可以改成别的）
 2. `git push -u origin master`  
 第一次推送master分支的所有内容（-u参数，git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来）
 3. `git push origin master`  
 本地提交后，推送最新修改到远程库
+ 本地没有仓库
 - `git clone git@github.com:mybuddy/gitskills.git`  
 从远程库克隆

## 3. 分支

### 3.1 分支基本命令

+ `git branch`  
查看分支
+ `git branch <name>`  
创建分支
+ `git checkout <name>`  
切换分支
+ `git checkout -b <name>`  
创建+切换分支
+ `git merge <name>`  
合并某分支到当前分支
+ `git branch -d <name>`  
删除分支
+ `git branch -D <name>`  
删除一个没有被合并过的分支（强行删除）
+ `git log --graph`  
`git log --graph --pretty=oneline --abbrev-commit`  
分支合并图
+ `git merge —no-ff -m '说明' <name>`  
不使用fast forward模式合并，合并会产生commit。fast forward模式合并不会产生commit。

### 3.2 冲突

当git自动合并分支遇到冲突时，必须先解决冲突，然后再提交，最后合并完成。

1. `git merge <name>` 尝试合并，遇到冲突，手动解决冲突
2. `git add 文件` 冲突解决后，add到暂存区
3. `git commit` 提交

### 3.3 保护工作区

当需临时开分支（如修复一个紧急的bug），而手头工作没有完成时，可以先保护工作现场，再开分支，待bug修复后，恢复工作现场。

+ `git stash`  
保护工作现场
+ `git stash list`  
查看工作现场
+ `git stash apply`  
恢复工作现场，stash内容并不删除
+ `git stash drop`  
删除工作现场
+ `git stash pop`  
恢复工作现场的同时，stash内容也一并删除
+ `git stash apply stash@{0}`  
可以多次stash，恢复的时候，先用`git stash list`查看，然后恢复指定的stash

## 4. 多人协作的工作模式

### 4.1 多人在同一公共分支开发

1. 从master拉一个公共分支，多人均在该公共分支开发；
2. 试图用`git push origin <branch-name>`推送自己的修改；
3. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；
4. 如果合并有冲突，则解决冲突，并在本地提交；
5. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功；  
如果`git pull`提示*“no tracking information”*，则说明本地分支和远程分支的链接关系没有创建，使用以下命令关联
`git branch --track origin/branch-name <branch-name>` 或 
`git branch --set-upstream-to=origin/branch-name <branch-name>`。

这种方式，若使用gitlab来合并代码、review代码，仅能在公共分支merge到master分支时，在gitlab上提merge request来完成。

### 4.2 多人在各自私有分支开发

多人在各自私有分支开发，时不时地merge到公共分支，并pull公共分支，merge到自己的分支，最后开发完毕再merge到公共分支。

> master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。
> 
![](http://oatuajceb.bkt.clouddn.com/image/git%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F.png)

对于我们使用gitlab来合并代码、review代码的情况，则具体如下：

1. 从远程库dev分支创建各自的分支dev1、dev2，各自本地除了自己的分支外，还有原分支dev；
2. RD1的本地dev1分支push到远程库dev1后，提merge request到dev分支，结对人review代码并accept merge request；
3. RD2使用 `git pull` 更新本地dev分支，然后通过`git merge dev2`在本地将dev分支 merge到dev2分支，并push到远程库dev2后，最后merge request到dev分支；

> 这个过程发生了2次merge，一个是私有分支merge到公共分支，通过在gitlab上提merge request完成；另一个是公共分支merge到私有分支，通过在本地使用`git merge`命令完成。

## 5. 远程库

+ `git remote -v`  
查看远程库信息
+ `git checkout -b branch-name origin/branch-name`  
在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致
+ `git branch --track origin/branch-name <branch-name>`  
`git branch --set-upstream-to=origin/branch-name <branch-name>`  
建立本地分支和远程分支的关联

## 6. 标签tag

+ `git tag <name> [commit id]`  
新建一个标签，默认为HEAD，也可以指定一个commit id
+ `git tag -a <tagname> -m '说明'`  
可以指定标签信息
+ `git tag -s <tagname> -m '说明'`  
可以用PGP签名标签
+ `git tag`  
查看所有标签
+ `git show <tagname>`  
查看标签信息
+ `git push origin <tagname>`  
推送一个本地标签
+ `git push origin --tags`  
推送全部未推送过的本地标签
+ `git tag -d <tagname>`  
删除一个本地标签
+ `git push origin :refs/tags/<tagname>`  
删除一个远程标签

## 7. 撤销命令

**reset/checkout/revert 区别**

### 7.1 commit level（reset、checkout、revert）

- **git reset**  
用于撤销自己的分支所做的修改。（会修改commit history）
 + `git reset --soft HEAD`  
 仅修改commit history
 + `git reset [--mixed] HEAD`  
 仅丢弃暂存区的修改，工作区不受影响（HEAD表示最新的版本）
 + `git reset --hard HEAD`  
 丢弃暂存区、工作区的修改 HEAD^，HEAD^^，HEAD~5，commit_id（前几位即可，如7位）

- **git checkout**  
可能会修改工作区，所以checkout的时候git会提醒
 + `git checkout branch_name`  
 （将HEAD移动到其他分支）用于切换分支
 + `git checkout commit_id`  
 （将HEAD移动到指定的commit，类似于上面）用于快速查看历史版本，但不可直接修改，修改必须拉相应分支
  
- **git revert**   
用于撤销公共的分支所做的修改。（不会修改commit history，而是新增一个commit）可能会修改工作区，所以revert的时候git会提醒
 + `git revert HEAD~2`  
 （仅撤销HEAD~2所做的修改，并创建一个新的commit） 

### 7.2 file level（reset、checkout）

- **git reset**  
 + `git reset HEAD [--] 文件`  
 --soft、--mixed、--hard参数无效，结果均为仅丢弃暂存区的修改，工作区不受影响

- **git checkout**  
 + `git checkout HEAD~2 [--] 文件`  
 （HEAD不移动）暂存区不修改，工作区修改，用于快速查看该文件的历史版本（效果类似于commit level的`git reset —hard HEAD~2`，但局限于该文件）  
如果checkout一个文件的某版本后，add并commit该文件，则效果类似revert该文件到某版本，不同的是该版本之后的所有修改均被撤销，而revert只会撤销指定版本的修改

>注：git命令中的文件、目录前可以加`--`以便与参数隔开。如`git checkout HEAD~2 -- 文件`。

## 8. 撤销的正确姿势

做了无数次试验后，总结的revert的姿势：

1. `git revert commit_id`，然后push，merge request  
优点：可以全局revert  
缺点：只能revert该commit的修改，如果要revert多次commit，则要多次revert最后再push，merge request  
2. `git checkout commit_id 文件1 文件2 [...文件n]`，然后add，commit，push，merge request  
优点：可以revert多次commit  
缺点：必须把要revert的文件一一列出来，不能全局revert

## 9. 其他

+ `git clone -b <branch> <remote_repo>`  
git clone默认会把仓库中的所有分支都复制到本地，该命令可仅克隆指定的分支

## 10. 参考
[廖雪峰git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)

[Reset, Checkout, and Revert](https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting/)

